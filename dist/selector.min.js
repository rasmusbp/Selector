(function(t,e){typeof exports==="object"&&typeof module!=="undefined"?e(exports):typeof define==="function"&&define.amd?define(["exports"],e):e(t.StatefulSelector=t.StatefulSelector||{})})(this,function(t){"use strict";var e={NOT_EXIST:t=>`${t} --> item does not exist.`,ALREADY_EXIST:t=>`${t} --> item already exist.`,READ_ONLY:t=>`${t} --> ${t} is a read only property`,ALREADY_SELECTED:t=>`${t} --> item is already selected.`,NOT_SELECTED:t=>`${t} --> item is not selected.`,NO_TRACKBY:t=>`${t} --> action only works in track-by mode.`,INVALID_TRACKBY_ITEM:t=>`${t} --> item(s) must be objects in track-by mode.`};class n{constructor({message,reason,data}){this.message=message;this.reason=reason;this.data=data}print(t){switch(t.level){case"throw":throw new Error(this.message);case"error":console.error(this.message,this.data);break;case"warn":console.warn(this.message,this.data);break;case"log":console.log(this.message,this.data);break;case"silent":break;default:console.log(this.message,this.data);break}return this}}const s=new WeakMap;const r="add";const o="remove";const i="select";const c="deselect";class a{constructor(t={items:[],selected:[]},r){const o=new Map;const i=new Map;const c={onChanges:new Set,onErrors:new Set};const a=Object.assign({trackBy:undefined,strict:false,debug:false,validators:[()=>true],providers:Object.assign({Error:n},r.providers)},r);a.logLevel=a.strict?"error":"warn";const u=({reason:reason,data:data,context="Selector"})=>{const t=e[reason]||(()=>"null");const n=a.providers.Error;return new n({message:`Selector@${t(context)}`,reason:reason,data:data})};const h=(t,e)=>{return e.reduce((e,n)=>{const s=T(n);t.set(s,n);return[...e,n]},[])};const f=(t,e)=>{return e.reduce((e,n)=>{const s=T(n);const r=t.delete(s);return r?[...e,n]:e},[])};const l=t=>{c.onChanges.forEach(e=>{e(t,this.state,this)})};const g=t=>{c.onErrors.forEach(e=>{e(t,this.state,this)})};const d=(t,e,n)=>{if(t.hasErrors){g(n);if(a.strict)return}if(t.hasChanges){l(e)}};const E=t=>o.get(T(t));const p=t=>o.has(T(t));const m=t=>i.has(T(t));const S=(t,e=a.logLevel)=>{if(t.length&&(a.strict||a.debug)){t.forEach(t=>t.print({level:e}))}};const y={all:{validate:t=>t},existing:{validate:E},adding:{iterator(t,e,n){return n(t,e)},validate(t,e){if(p(t)){return u({reason:"ALREADY_EXIST",data:t,context:e})}else{return t}}},getting:{validate(t,e){return p(t)?E(t):u({reason:"NOT_EXIST",data:t,context:e})}},selecting:{validate(t,e){if(!p(t)){return u({reason:"NOT_EXIST",data:t,context:e})}else if(m(t)){return u({reason:"ALREADY_SELECTED",data:E(t),context:e})}else{return E(t)}}},deselecting:{validate(t,e){if(!p(t)){return u({reason:"NOT_EXIST",data:t,context:e})}else if(!m(t)){return u({reason:"NOT_SELECTED",data:E(t),context:e})}else{return E(t)}}}};const v=(t,e)=>{if(typeof t==="function"){if(e){const{initialState}=s.get(this);return e(this.state,initialState,t)}else{return this.state.items.reduce((e,n,s)=>{if(t(n,s)===true){return[...e,n]}return e},[])}}else if(Array.isArray(t)){return t}else{return[t]}};const C=(t,e)=>{if(!e)return t;if(e instanceof a.providers.Error){t.errors.push(e)}else{t.hits.push(e)}return t};const A=(t,e,n)=>{const s=v(e,t.iterator);const r={hits:[],errors:[]};return s.reduce((e,s)=>{return C(e,t.validate(s,n))},r)};const T=t=>{const{trackBy}=a;if(!trackBy||typeof t!=="object"&&t!==null){return t}if(typeof trackBy==="function"){return trackBy(t)}return t[trackBy]};const w=t=>{if(Array.isArray(t)){return{items:t.slice(),selected:[]}}return{items:Array.isArray(t.items)?t.items.slice():t.items,selected:Array.isArray(t.selected)?t.selected.slice():t.selected}};s.set(this,{log:S,config:a,itemsMap:o,resolverFor:y,subscribers:c,selectionsMap:i,resolveInput:v,resolveKey:T,resolveItemsWith:A,createError:u,createStateObject:w,has:p,get:E,isSelected:m,addTo:h,removeFrom:f,dispatch:d});this.setState(t);s.get(this).initialState=this.state}static mirror(t){return{[r]:(t[o]||[]).slice(0),[o]:(t[r]||[]).slice(0),[i]:(t[c]||[]).slice(0),[c]:(t[i]||[]).slice(0)}}subscribe(t,e){const{subscribers}=s.get(this);const{onChanges,onErrors}=subscribers;onChanges.add(t);if(e){onErrors.add(e)}return()=>{onChanges.delete(t);onErrors.delete(e);return this}}select(t){return this.applyChange({[i]:t})}deselect(t){return this.applyChange({[c]:t})}selectAll(){return this.deselectAll().select(this.state.items)}deselectAll(){return this.deselect(this.state.selected)}invert(){return this.toggle(this.state.items)}toggle(t){const{resolveInput,isSelected}=s.get(this);const e=resolveInput(t);const n=e.reduce((t,e)=>{if(isSelected(e)){t[c].push(e)}else{t[i].push(e)}return t},{[i]:[],[c]:[]});return this.applyChange(n)}add(t){return this.applyChange({[r]:t})}remove(t){return this.applyChange({[o]:t})}removeAll(){return this.remove(this.state.items)}reset(){const{initialState}=s.get(this);return this.setState(initialState)}isSelected(t){const{resolveItemsWith,resolverFor,isSelected,log}=s.get(this);if(!this.hasSelections)return false;const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t,"isSelected");log(errors$$1,"warn");return hits.every(isSelected)}isSomeSelected(t){const{resolveItemsWith,resolverFor,isSelected,log}=s.get(this);if(!this.hasSelections)return false;const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t,"isSomeSelected");log(errors$$1,"warn");return hits.some(isSelected)}isOnlySelected(t){const{resolveItemsWith,resolverFor,isSelected,log}=s.get(this);if(!this.hasSelections)return false;const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t,"isOnlySelected");log(errors$$1,"warn");return!!hits.length&&hits.every(isSelected)&&this.state.selected.length===hits.length}has(t){const{resolveItemsWith,resolverFor,has}=s.get(this);const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.all,t);return!!hits.length&&hits.every(has)}hasSome(t){const{resolveItemsWith,resolverFor}=s.get(this);const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t);return!!hits.length}swap(t,e){const{config,log,createError,resolveItemsWith,resolverFor,resolveKey,isSelected,itemsMap,dispatch,selectionsMap}=s.get(this);const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t,"swapping");let n=false;if(errors$$1.length){n=true;log(errors$$1)}const a=hits[0];const u=resolveKey(a);const h=isSelected(a);let f=false;if(!n){f=true;itemsMap.set(u,e);if(h){selectionsMap.set(u,e)}}dispatch({hasChanges:f,hasErrors:n},{[r]:[e],[i]:h?[e]:[],[c]:h?[a]:[],[o]:[a]},errors$$1);return this}setState(t){const{state}=this;const{createStateObject}=s.get(this);const{items,selected}=createStateObject(t);return this.applyChange({[o]:state.items,[r]:items,[i]:selected})}applyChange(t){const{log,config,addTo,removeFrom,dispatch,resolveItemsWith,resolverFor,itemsMap,selectionsMap}=s.get(this);const e=[o,r,c,i];const n=e.reduce((e,n)=>{if(!t[n]&&t[n]!==0){return e}const s={[o]:()=>{const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t[o],o);log(errors$$1);e.errors.push(...errors$$1);e.hasErrors=e.hasErrors||!!errors$$1.length;const n=!(e.hasErrors&&config.strict)?removeFrom(itemsMap,hits):[];e.hasChanges=e.hasChanges||!!n.length;n.forEach(t=>{if(this.isSelected(t)){e.changes[c].push(...removeFrom(selectionsMap,[t]))}});e.changes[o]=n},[r]:()=>{const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.adding,t[r],r);log(errors$$1);e.errors.push(...errors$$1);e.hasErrors=e.hasErrors||!!errors$$1.length;const n=!(e.hasErrors&&config.strict)?addTo(itemsMap,hits):[];e.hasChanges=e.hasChanges||!!n.length;e.changes[r]=n},[c]:()=>{const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.deselecting,t[c],c);log(errors$$1);e.errors.push(...errors$$1);e.hasErrors=e.hasErrors||!!errors$$1.length;const n=!(e.hasErrors&&config.strict)?removeFrom(selectionsMap,hits):[];e.hasChanges=e.hasChanges||!!n.length;e.changes[c].push(...n)},[i]:()=>{const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.selecting,t[i],i);log(errors$$1);e.errors.push(...errors$$1);e.hasErrors=e.hasErrors||!!errors$$1.length;const n=!(e.hasErrors&&config.strict)?addTo(selectionsMap,hits):[];e.hasChanges=e.hasChanges||!!n.length;e.changes[i]=n}};s[n]();return e},{hasChanges:false,hasErrors:false,changes:{[r]:[],[i]:[],[c]:[],[o]:[]},errors:[]});const{hasChanges,hasErrors}=n;dispatch({hasChanges:hasChanges,hasErrors:hasErrors},n.changes,n.errors);return this}get state(){const{selectionsMap,itemsMap}=s.get(this);return{items:Array.from(itemsMap.values()),selected:Array.from(selectionsMap.values())}}get hasSelections(){const{selectionsMap}=s.get(this);return!!selectionsMap.size}get hasItems(){const{itemsMap}=s.get(this);return!!itemsMap.size}get isAllSelected(){const{itemsMap,selectionsMap}=s.get(this);return itemsMap.size===selectionsMap.size}get isValid(){const{validators}=s.get(this).config;return validators.every(t=>t(this.state,this))}}function u(t,e={}){return new a(t,e)}const h={createSelector:u,Selector:a};const f=u([{id:"1",name:"John"}]);const l=f.state.selected;const g=l.map(t=>{t.name=t.name+" is awesome!";return t});g.forEach(t=>console.log(t.name));l.forEach(t=>console.log(t.name));t["default"]=h;t.createSelector=u;t.Selector=a;Object.defineProperty(t,"__esModule",{value:true})});