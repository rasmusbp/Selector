(function(t,e){typeof exports==="object"&&typeof module!=="undefined"?e(exports):typeof define==="function"&&define.amd?define(["exports"],e):e(t.StatefulSelector=t.StatefulSelector||{})})(this,function(t){"use strict";var e={NOT_EXIST:t=>`${t} --> item does not exist.`,ALREADY_EXIST:t=>`${t} --> item already exist.`,READ_ONLY:t=>`${t} --> ${t} is a read only property`,ALREADY_SELECTED:t=>`${t} --> item is already selected.`,NOT_SELECTED:t=>`${t} --> item is not selected.`,INVALID_TYPE:t=>`${t} --> item must be of same type.`,INVALID_STATE:t=>`${t} --> provided state is not valid. 
                    Make sure to provide valid 'items' and 'selections' arrays.`};class n{constructor({message,reason,data}){this.message=message;this.reason=reason;this.data=data}print(t){switch(t.level){case"throw":throw new Error(this.message);case"error":console.error(this.message,this.data);break;case"warn":console.warn(this.message,this.data);break;case"log":console.log(this.message,this.data);break;case"silent":break;default:console.log(this.message,this.data);break}return this}}const s=new WeakMap;const r="add";const o="remove";const i="select";const c="deselect";class a{constructor(t={items:[],selected:[]},r){const o=new Map;const i=new Map;const c={onChanges:new Set,onErrors:new Set};const a=Object.assign({trackBy:undefined,strict:false,debug:false,validators:[()=>true],providers:Object.assign({Error:n},r.providers)},r);a.logLevel=a.strict?"error":"warn";const u=({reason:reason,data:data,context="Selector"})=>{const t=e[reason]||(()=>"null");const n=a.providers.Error;return new n({message:`Selector@${t(context)}`,reason:reason,data:data})};const h=(t,e)=>{return e.reduce((e,n)=>{const s=T(n);t.set(s,n);return[...e,n]},[])};const f=(t,e)=>{return e.reduce((e,n)=>{const s=T(n);const r=t.delete(s);return r?[...e,n]:e},[])};const l=t=>{c.onChanges.forEach(e=>{e(t,this.state,this)})};const g=t=>{c.onErrors.forEach(e=>{e(t,this.state,this)})};const d=(t,e,n)=>{if(t.hasErrors){g(n);if(a.strict)return}if(t.hasChanges){l(e)}};const E=t=>{return o.get(T(t))};const p=t=>{return o.has(T(t))};const S=t=>{return i.has(T(t))};const m=(t,e=a.logLevel)=>{if(t.length&&(a.strict||a.debug)){t.forEach(t=>t.print({level:e}))}};const y={all:{validate:t=>t},existing:{validate:E},adding:{iterator(t,e){return e(t)},validate(t,e){return!p(t)?t:u({reason:"ALREADY_EXIST",data:t,context:e})}},getting:{validate(t,e){return p(t)?E(t):u({reason:"NOT_EXIST",data:t,context:e})}},selecting:{validate(t,e){if(!p(t)){return u({reason:"NOT_EXIST",data:t,context:e})}else if(S(t)){return u({reason:"ALREADY_SELECTED",data:E(t),context:e})}else{return E(t)}}},deSelecting:{validate(t,e){if(!p(t)){return u({reason:"NOT_EXIST",data:t,context:e})}else if(!S(t)){return u({reason:"NOT_SELECTED",data:E(t),context:e})}else{return E(t)}}}};const v=(t,e)=>{if(typeof t==="function"){if(e){return e(this.state,t)}else{return this.state.items.reduce((e,n,s)=>{if(t(n,s)===true){return[...e,n]}return e},[])}}else if(Array.isArray(t)){return t}else{return[t]}};const A=(t,e)=>{if(!e)return t;if(e instanceof a.providers.Error){t.errors.push(e)}else{t.hits.push(e)}return t};const C=(t,e,n)=>{const s=v.call(this,e,t.iterator);const r={hits:[],errors:[]};return s.reduce((e,s)=>{return A(e,t.validate(s,n))},r)};const T=t=>{const{trackBy}=a;if(!trackBy||typeof t!=="object"&&t!==null){return t}if(typeof trackBy==="function"){return trackBy(t)}return t[trackBy]};const w=t=>{if(!t)return false;return[typeof t==="object",Array.isArray(t.items),Array.isArray(t.selected)].every(t=>t)};const _=(t,e)=>{const n=()=>{return u({reason:"INVALID_STATE",context:e,data:t}).print({level:"throw"})};if(!t){n()}if(Array.isArray(t)){return{get:()=>({items:t.slice(),selected:[]})}}return{get:w(t)?()=>t:n}};s.set(this,{log:m,config:a,itemsMap:o,resolverFor:y,subscribers:c,selectedMap:i,resolveInput:v,resolveItemsWith:C,createStateError:u,createStateGetter:_,has:p,get:E,isSelected:S,addTo:h,removeFrom:f,dispatch:d});this.setState(_(t,"initialState").get());s.get(this).initialState=this.state}static mirror(t){return{[r]:(t[o]||[]).slice(0),[o]:(t[r]||[]).slice(0),[i]:(t[c]||[]).slice(0),[c]:(t[i]||[]).slice(0)}}subscribe(t,e){const{subscribers}=s.get(this);const{onChanges,onErrors}=subscribers;onChanges.add(t);if(e){onErrors.add(e)}return()=>{onChanges.delete(t);onErrors.delete(e);return this}}select(t){return this.applyChange({[i]:t})}deSelect(t){return this.applyChange({[c]:t})}selectAll(){return this.deSelectAll().select(this.state.items)}deSelectAll(){return this.deSelect(this.state.selected)}invert(){return this.toggle(this.state.items)}toggle(t){const{resolveInput,isSelected}=s.get(this);const e=resolveInput(t);const n=e.reduce((t,e)=>{if(isSelected(e)){t[c].push(e)}else{t[i].push(e)}return t},{[i]:[],[c]:[]});return this.applyChange(n)}add(t){return this.applyChange({[r]:t})}remove(t){return this.applyChange({[o]:t})}removeAll(){return this.remove(this.state.items)}reset(){const{initialState}=s.get(this);return this.setState(initialState)}isSelected(t){const{resolveItemsWith,resolverFor,isSelected,log}=s.get(this);if(!this.hasSelections)return false;const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t,"isSelected");log(errors$$1,"warn");return hits.every(isSelected)}isSomeSelected(t){const{resolveItemsWith,resolverFor,isSelected,log}=s.get(this);if(!this.hasSelections)return false;const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t,"isSomeSelected");log(errors$$1,"warn");return hits.some(isSelected)}isOnlySelected(t){const{resolveItemsWith,resolverFor,isSelected,log}=s.get(this);if(!this.hasSelections)return false;const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t,"isOnlySelected");log(errors$$1,"warn");return!!hits.length&&hits.every(isSelected)&&this.state.selected.length===hits.length}has(t){const{resolveItemsWith,resolverFor,has}=s.get(this);const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.all,t);return!!hits.length&&hits.every(has)}hasSome(t){const{resolveItemsWith,resolverFor}=s.get(this);const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t);return!!hits.length}swap(t,e){const{dispatch,itemsMap,selectedMap,resolveItemsWith,resolveKey}=s.get(this);if(!this.has(t)){throw new Error(`Selector#swap -> cannot swap non-existing item`)}const n=resolveItemsWith(t)[0];const i=resolveKey(t);if(this.isSelected(n)){selectedMap.set(i,e)}itemsMap.set(i,e);dispatch({[r]:[itemsMap.get(i)],[o]:[n]});return this}setState(t){const{state}=this;const{items,selected}=t;return this.applyChange({[o]:state.items,[r]:items,[i]:selected})}applyChange(t){const{log,config,addTo,removeFrom,dispatch,resolveItemsWith,resolverFor,itemsMap,selectedMap}=s.get(this);const e=[o,r,c,i];const n=e.reduce((e,n)=>{if(!t[n]&&t[n]!==0){return e}const s={[o]:()=>{const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.getting,t[o],o);log(errors$$1);e.errors.push(...errors$$1);e.hasErrors=e.hasErrors||!!errors$$1.length;const n=!(e.hasErrors&&config.strict)?removeFrom(itemsMap,hits):[];e.hasChanges=e.hasChanges||!!n.length;n.forEach(t=>{if(this.isSelected(t)){e.changes[c].push(...removeFrom(selectedMap,[t]))}});e.changes[o]=n},[r]:()=>{const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.adding,t[r],r);log(errors$$1);e.errors.push(...errors$$1);e.hasErrors=e.hasErrors||!!errors$$1.length;const n=!(e.hasErrors&&config.strict)?addTo(itemsMap,hits):[];e.hasChanges=e.hasChanges||!!n.length;e.changes[r]=n},[c]:()=>{const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.deSelecting,t[c],c);log(errors$$1);e.errors.push(...errors$$1);e.hasErrors=e.hasErrors||!!errors$$1.length;const n=!(e.hasErrors&&config.strict)?removeFrom(selectedMap,hits):[];e.hasChanges=e.hasChanges||!!n.length;e.changes[c].push(...n)},[i]:()=>{const{hits,errors:errors$$1}=resolveItemsWith(resolverFor.selecting,t[i],i);log(errors$$1);e.errors.push(...errors$$1);e.hasErrors=e.hasErrors||!!errors$$1.length;const n=!(e.hasErrors&&config.strict)?addTo(selectedMap,hits):[];e.hasChanges=e.hasChanges||!!n.length;e.changes[i]=n}};s[n]();return e},{hasChanges:false,hasErrors:false,changes:{[r]:[],[i]:[],[c]:[],[o]:[]},errors:[]});const{hasChanges,hasErrors}=n;dispatch({hasChanges:hasChanges,hasErrors:hasErrors},n.changes,n.errors);return this}get state(){const{selectedMap,itemsMap}=s.get(this);return{items:Array.from(itemsMap.values()),selected:Array.from(selectedMap.values())}}get hasSelections(){const{selectedMap}=s.get(this);return Boolean(selectedMap.size)}get hasItems(){const{itemsMap}=s.get(this);return Boolean(itemsMap.size)}get isAllSelected(){return this.isSelected(this.state.items)}get isValid(){const{validators}=s.get(this).config;return validators.every(t=>t(this.state,this))}}function u(t,e={}){return new a(t,e)}const h={createSelector:u,Selector:a};const f=u([1,2,3,4]);f.select([2,3]);console.log(f.state);f.toggle(t=>{return t===2||t===4});console.log(f.state);t["default"]=h;t.createSelector=u;t.Selector=a;Object.defineProperty(t,"__esModule",{value:true})});